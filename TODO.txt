== github ==

turn these TODO items into github issues?

== separation of detection vs mutation ==

 * It might be better if FR/JT were rewritten so that there were
   something like JT but which just *finds* "escaping" jumps, without
   mutating anything, first. Then we can rewrite those jumps as
   appropriate depending on whether finallyCanCompleteNormally, ie
   as "break #Try" or "break #J1/#J2/etc".

   Similarly, for ReturnViaBreak, could consider something which finds
   "escaping returns". Specifically, we're interested in return from
   try/catch which has a finally block. Those are the ones which need
   to be routed through a copy of the finally block (in order to
   rewrite without "finally") and therefore need to be translated to a
   "break". Rewriting just those returns would eliminate unnecessary
   changes and have the nice side effect of making RVB idempotent (as
   noted below).

== bugs ==

 * FullCheckerTest is failing. Checker is rejecting the code due to
   initialization issue with the generated variable holding the return
   value. TODO: TreeDumper2 on generated transformed source
   vs. vanilla javac on transformed source.

/Foo.java:1: error: [return.type.incompatible] incompatible types in return.
public class Foo {
       ^
  found   : @UnknownInitialization @Nullable String
  required: @Initialized @NonNull String
1 error
/Foo.java:1: error: [return.type.incompatible] incompatible types in return.
public class Foo { public int foo() { while (true) { try { break; } finally { return 1; }}}}
       ^
  found   : @UnknownInitialization @NonNull int
  required: @Initialized @NonNull int
1 error
------------- ---------------- ---------------
Testcase: testTryWithBreak(edp.javac.proc.FullCheckerTest):	Caused an ERROR
compile failed
java.lang.RuntimeException: compile failed
	at edp.javac.compiler.CompilerImpl.run(CompilerImpl.java:138)
	at edp.javac.compiler.CompilerImpl.compileAndLoad(CompilerImpl.java:118)
	at edp.javac.compiler.AbstractTryTests.run(AbstractTryTests.java:40)
	at edp.javac.compiler.AbstractTryTests._test(AbstractTryTests.java:71)
	at edp.javac.compiler.AbstractTryTests._test(AbstractTryTests.java:75)
	at edp.javac.compiler.AbstractTryTests._t1(AbstractTryTests.java:107)
	at edp.javac.compiler.AbstractTryTests._t(AbstractTryTests.java:118)
	at edp.javac.compiler.AbstractTryTests.testTryWithBreak(AbstractTryTests.java:200)


Testcase: test1c(edp.javac.proc.FullCheckerTest):	Caused an ERROR
compile failed
java.lang.RuntimeException: compile failed
	at edp.javac.compiler.CompilerImpl.run(CompilerImpl.java:138)
	at edp.javac.compiler.CompilerImpl.compileAndLoad(CompilerImpl.java:118)
	at edp.javac.compiler.AbstractTryTests.run(AbstractTryTests.java:40)
	at edp.javac.compiler.AbstractTryTests._test(AbstractTryTests.java:71)
	at edp.javac.compiler.AbstractTryTests.test1c(AbstractTryTests.java:316)


 * general: there are probably other cases where a generated var decl
   needs to have its source position ("pos" field) set, as done in
   r4358; see AbstractTryTests testAnonymousInnerClass testcase.

   AbstractTryTests wrapAnonInner does seem to have revealed other
   problems. looks like FinallyRemover transformation is being applied
   but RVB is not, for method within anonymous inner class. probably a
   simple stupid Visitor mistake... RVB is a TreeTranslator. It only
   overrides visitMethoDef, to do its thing, but the problem is that
   *within* a method def there can be other method defs, and it needs
   to make sure those are translated too. eg even the 'expr' in a
   "this" or "super" ctor call could have a method def in it - for
   anonymous class (or possibly lambda?).

   fixing that by running the translator on the new method body (which
   will find any other method defs within the method def) seems to fix
   those issues. remaining TODO is to audit other TreeTranslators for
   same mistake.

   debugging idea..... would be nice if Tree{Printer,Dumper}{1,2}
   output could be printed for failing tests only. would be nice if
   it could be dumped to files instead of stdout too...

== other processor ideas ==

 * check the impact of JCTree "pos" field by mutating it. set it to
   zero everywhere. make it go backwards (start at MAXINT and
   decrement).

 * StringifyBareAssertions: assert EXPR; => assert EXPR : "EXPR";

== idempotence ==

It would be nice if processors were idempotent. ReturnViaBreak is not,
I'm pretty sure. Maybe the others are.

== Checker ==

Why does Checker allow "m.sym" (where m is javac JCMethodDecl) to be
dereferenced, when it can be null? Is that a bug in a stub file or
annotated JDK or something? Is it running with unsafe settings?

Same thing applies to JCBreak.{label,target} and presumably tons of
other stuff.

== modules / dependencies ==

Would like to split up various modules and manage them independently,
but for now it's convenient to have everything in one tree, with
minimal dependencies.

Current dependencies:

 * JDK 8             (tested with 1.8.0_66)
 * Checker Framework (tested with 1.9.10)
 * JUnit             (tested with 4.10)

== tests ==

 * more tests always good...
 * code coverage!
 * would be nice if AbstractTryTests (eg) could read code fragments
   from files as well as literal strings.

== other ==

 * grep for TODO and XXX...

== code style / hygiene ==

Checkstyle can probably check the following:

 * no unused imports
 * properly sorted imports
 * no tabs, no trailing whitespace

== "control" module ==

maybe copy 'control' subpkg from java-misc/jtree as well, even though
it's pretty much just a sketch, and not sure what it's really good
for.

